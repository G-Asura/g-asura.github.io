[{"id":"96badec9d2a8ff4ed297d972e3ac1aab","title":"容器技术实现原理","content":"\n\n\n\n\n\n\n\n\n开始之前为了方便的理解容器，先举个简单的例子：假如把一套房子比作操作系统，这套房子的中控就是内核，每间卧室可以理解为是虚拟化出来的虚拟机，他们可以拥有各自独立的中控，假设这套房子中控控制着台冰箱，冰箱里有多个隔层，那么每个隔层就是一个个独立运行的容器。\nLinux容器进程在了解容器之前，我们有必要对Linux进程有一定的了解，因为容器本质上就是一个特殊的进程。关于Linux进程我们先看看下面这张图\n\nLinux操作系统启动后切进用户态随之开启进程调度，首先会往GDT（全局描述符表）里写入两个结构TSS（任务状态段）和LDT（局部描述符表）。  \n\n\nTSS用来保存和恢复进程的上下文，即各个寄存器的信息；\nLDT与GDT相对应，内核态的代码用GDT里的数据段和代码段，而用户态的进程代码用每个用户自己的LDT里的数据段和代码段。\n\n\n接下来会初始化一个长度为64的task_struct的数组来存放所有进程信息，并附上初始值init_task.init，即0号进程的信息。\n最后设置了时钟中断0x20和系统调用0x80，一个作为进程调度的起点，一个作为用户程序调用操作系统功能的桥梁。\n\n\n\n\n\n\n\n\n\n\n struct task_struct {/* these are hardcoded - don’t touch /    long state; / -1 unrunnable, 0 runnable, &gt;0 stopped /    long counter;    long priority;    long signal;    struct sigaction sigaction[32];    long blocked; / bitmap of masked signals /  / various fields /    int exit_code;    unsigned long start_code,end_code,end_data,brk,start_stack;    long pid,father,pgrp,session,leader;    unsigned short uid,euid,suid;    unsigned short gid,egid,sgid;    long alarm;    long utime,stime,cutime,cstime,start_time;    unsigned short used_math;  / file system info /    int tty;  / -1 if no tty, so it must be signed /    unsigned short umask;    struct m_inode * pwd;    struct m_inode * root;    struct m_inode * executable;    unsigned long close_on_exec;    struct file * filp[NR_OPEN];  / ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss /    struct desc_struct ldt[3];  / tss for this task */    struct tss_struct tss;};  \n关于Linux进程，我们还有必要了解一下0号进程和1号进程，尤其是1号进程和容器关系密切。  \n\n0号进程：0号进程是系统初始化时创建的，即所有进程的父进程，其数据大部分是由预先定义好的INIT_TASK，INIT_MM等宏初始化；  \n1号进程：0号进程通过调用kernel_thread创建一个内核线程去执行init函数，init函数在完成内核初始化后调用execve系统调用，以装入用户空间的可执行程序/sbin/init，这就诞生了真正意义上的init进程，即1号进程。1号进程主要负责执行内核初始化工作及系统配置，并创建若干用于高速缓存和虚拟主存管理的内核线程。  \n\n1号进程创建后就可以调用execve（）运行init程序，演变成用户态1号进程，根据/etc/initab的配置，接着创建编号1号，2号。。。注册进程getty，从而形成Linux的树形结构进程列表。  \n至此，我们了解了Linux进程的创建过程。那么容器和进程又有什么关系呢？前面我们已经说过了，容器本质上是一个特殊的进程，他的特殊之处又在哪呢？容器进程的特殊性表现在容器进程永远认为自己是1号进程，然而它在系统中的进程号可能是99号，而让容器产生这种特性的技术是Linux的PID Namespace机制。  \nNamespace在我们开始了解Linux Namespace机制之前，我们先来看看上面说的容器进程伪装隔离的实现原理：Linux在创建用户态进程是会调用clone()方法并返回一个int类型的PIDint pid = clone(main_function, stack_size, SIGCHLD, NULL);如果我们传入一个可选参数CLONE_NEWPID，那么新创建的进程将会是一个全新的进程空间，在这个进程空间里，它的进程号就是1，这就是一个容器。int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);上面就是PID Namespace的实现。  \nLinux Namespace简单来说就是一种资源隔离的机制，主要是三个系统调用clone()，unshare()，setns()。上面提到的进程隔离PID namespace只是众多Namespace中的一种。Linux中还提供了如Mount、Network、User、UTS、IPC等多种资源隔离机制：\n\n\n\nNamespace\n用途\n\n\n\nPID Namespace\n隔离进程的ID\n\n\nMount Namespace\n隔离文件系统挂载点\n\n\nNetwork Namespace\n隔离网络资源\n\n\nUser Namespace\n隔离用户和用户组ID\n\n\nUTS Namespace\n隔离主机名和域名信息\n\n\nIPC Namespace\n隔离进程间通信\n\n\n可以在/proc/$pid/ns目录查看Namespace文件信息。Namespace机制虽然能帮助我们隔离了资源互不干扰，但是其本质还是在同一个内核进程上创建出来的，共享着宿主机内核，这就限制了不能在不同架构下运行相同的镜像，比如，arm架构的服务器不能运行x86架构下制作的镜像。由于容器进程是共享着宿主机资源，如果只是通过Namespace对容器进行隔离，并不能有效的限制容器之间的资源争抢，以及资源问题导致的容器间运行互相干扰，这时就需要另一项技术Cgroup，对容器进行资源限制。  \nCgroupLinux Cgroup 即 Linux Control Group。它最主要的作用是限制一个进程组资源，包括CPU，Memory，磁盘，带宽等。通常可以在/sys/fs/cgroup路径下看到相应的文件信息，可以通过下面命令查看：mount -t cgroup  \nCgroup通过下面几个子系统协调完成工作：  \n\n\n\n子系统\n用途\n\n\n\ndevices\n设备权限控制\n\n\ncpuset\n分配指定的CPU和内存节点\n\n\nCPU\n控制CPU使用率\n\n\ncpuacct\n统计CPU使用情况\n\n\nmemory\n限制内存的使用上限\n\n\nfreezer\n暂停Cgroup中的进程\n\n\nblkio\n限制进程的块设备io\n\n\nnet_cls\n配合流控限制网络带宽\n\n\nnet_prio\n设置进程的网络流量优先级\n\n\nperf_event\n允许Perf工具基于Cgroup分组做性能检测\n\n\nhuge_tlb\n限制HugeTLB使用\n\n\nns\n可以使不同cgroups下面的进程使用不同的namespace\n\n\n内核使用cgroup结构体来表示一个cgroup对一个或者某几个cgroup子系统的资源限制，cgroup结构体就组成了一个树结构。在这个cgroup树上的节点都有一个控制任务列表，一个cgroup可以控制多个进程，同时一个进程也可以加入到多个cgroup中，进程与cgroup是多对多的关系。\n网络我们已经了解到容器是通过Namespace进行资源隔离和Cgroup进行资源限制创建出来的特殊进程，然而新创建的容器怎么与宿主机网络通信以及宿主机上其他Namespace进行通信？这是就要用到上面提到的Network Namespace。Network Namespace的作用是创建以及管理Namespace的网络。可以通过Network Namespace创建多个隔离的网络空间，每个网络空间都拥有独自的网络栈信息。俩个Namespace之间通信可以通过Linux提供的网卡对veth pair实现，但是多个Namespace之间通信如果还借助veth pair来实现就会十分复杂，这个时候就需要借助虚拟网络来实现，虚拟网络有以下三种模式：  \n\n桥接模式\nNAT模式\n主机模式文件系统通过Namespace和Cgroup可以有效的隔离和限制容器的运行环境，但是程序的运行还需要文件系统的支撑，这时就要用到我们上面说的Mount Namespace对容器运行的文件系统进行隔离。如果不修改根目录的挂载点，那么容器启动之后会默认继承宿主机的挂载点，如果修改了根目录的挂载点，那么我们创建容器后会得到一个空的根目录。Linux的文件目录挂载涉及下面几个工具：  \n\n\nchroot：全称change root file system，这个命令能帮我们将任意目录转化为指定进程的根目录；\nrootfs：负责把除操作系统内核外的文件、配置和目录挂载到容器进程的根目录；\nUnionFS：不同容器的rootfs大多是重合的，为了有效的利用宿主机存储空间，这是就需要对重复的文件就行合并，也就产生了联合挂载Union File System的挂载方式，将多个不同位置的目录联合挂载到同一个目录下面，这也是Docker采用的技术。\n\n镜像Docker结合UnionFS技术，使用多个增量的rootfs联合挂载一个完整的rootfs，就此诞生了分层镜像。这样的分层结构极大的利用了宿主机的存储空间，并且还能基础镜像上进行堆叠不同的层，使得使用更加灵活，扩展性更强，同时保证了基础镜像的强一致性。Docker image分层结构：\n总结通过对进程、Namespace、Cgroup和Rootfs的了解，容器归根结底是一个特殊的进程，它的特殊性可以概括为下面的等式：容器 = Namespace + Cgroups + Rootfs + 容器引擎\n","slug":"容器技术实现原理/index","date":"2022-04-05T14:56:56.000Z","categories_index":"Container","tags_index":"Linux,Container","author_index":"Asura"},{"id":"f21ed2995d94acc11636251a32951b12","title":"开源协议对比","content":"\n\n\n\n\n\n\n\n\n当今开源软件基本都会选择自己的开源协议，这些开源协议中大部分都是由Open Source Initiative（OSI）批准通过的。\n我们都知道现在大部分开源协议都是由Open Source Initiative（简称 OSI）批准通过的，OSI即开放源代码促进会，是一个旨在推动开源软件发展的非盈利组织，其中常见的有Apache-2.0，MIT，BSD，GPL等等，其他开源协议可以查看 这里。\n作为一个开发者，我们身处的这个时代充斥着各式各样的开源项目，当我们去使用或者自己开源代码的时候，对开源协议的理解和选择尤其重要，所以在这里总结和对比当下主流的开源协议，供大家参考。\n话不多说，先看一下各开源协议对比图：\nApache License 2.0 (Apache-2.0)Apache-2.0相信大家都不会陌生，是Apache开源组织采用的协议。该开源协议授予项目版权及专利许可，鼓励共享代码，同时允许需改代码，作为开源或商业软件再发布。  \n\n\n\n\n\n\n\n\n\n“Derivative Works” shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.“Contribution” shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, “submitted” means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as “Not a Contribution.”\n 再发布，需要遵守下面几点要求：\n\n\n\n\n\n\n\n\n\n1.You must give any other recipients of the Work or Derivative Works a copy of this License; and2.You must cause any modified files to carry prominent notices stating that You changed the files; and3.You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and4.If the Work includes a “NOTICE” text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.\n\n 必须向作品或衍生作品的任何其他接收者提供本许可的副本；\n必须使任何修改后的文件带有显着的通知，说明已更改文件；\n必须以您分发的任何衍生作品的源形式保留作品源形式的所有版权、专利、商标和归属通知，不包括那些与衍生作品的任何部分无关的通知；\n如果作品在其分发中包含“通知”文本文件，则您分发的任何衍生作品必须包含该通知文件中包含的归属通知的可读副本，不包括那些不属于任何部分的通知衍生作品，至少位于以下位置之一： 在作为衍生作品的一部分分发的 NOTICE 文本文件中；如果与衍生作品一起提供，则在源表格或文档中；或者，在衍生作品生成的显示中，如果此类第三方通知通常出现以及出现在何处。NOTICE 文件的内容仅供参考，不得修改许可。您可以在您分发的衍生作品中添加您自己的归属通知，与作品的通知文本一起或作为附录添加\n\n可以说Apache-2.0给予了开发足够的自由的同时极大程度的保护了原作者的权益。我们熟知的遵循Apache-2.0协议的开源项目有Kubernetes，Android等\nMITMIT也是我们熟知的开源协议，出自麻省理工学院的许可证，是一种极度开放自由的开源协议。作者只需保留版权，开发者可以免费且不受限的处理该软件，包括但不限于使用、复制、修改、合并的权利、发布、分发、再许可和/或出售本软件的副本，并允许向其提供本软件的人这样做，但是必须保留该软件的版权声明和许可声明。\n\n\n\n\n\n\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.我们熟知的遵循MIT协议的开源项目有React，Node等\nBSDBSD有多个版本，当今使用较多的是2-Clause BSD也被称为Simplified BSD License或者FreeBSD License，还有修订版本3-Clause BSD。BSD也是一个给予开发者极大自由度的开源协议，允许开发者以源代码和二进制的形式进行使用和重新发布，但必须遵循以下要求：  \n\n\n\n\n\n\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.  \nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.  \nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.  \n\n\n源代码的再分发必须保留原先版权声明、此条件列表和以下免责声明。\n二进制形式的再分发必须在随分发提供的文档和/或其他材料中复制上述版权声明、此条件列表和以下免责声明。\n未经事先书面许可，不得使用版权所有者的姓名或其贡献者的姓名来认可或推广从本软件衍生的产品。\n\n\n\n\n\n\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  \n我们熟知的遵循BSD协议的开源项目有蓝鲸，Matlab等\nGPLGPL协议给予开发者的自由度并不像Apache，BSD，MIT这么高，更确切的说是对商业化应用并不是很友好，允许开源代码的免费使用和再发布，但是不能作为闭源的商业软件。GPL本身还具备很强的传递性，任何修改和衍生品都必须遵循GPL协议。  \n\n\n\n\n\n\n\n\n\nWe protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the software.Also, for each author’s protection and ours, we want to make certain that everyone understands that there is no warranty for this free software. If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors’ reputations.Finally, any free program is threatened constantly by software patents. We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary. To prevent this, we have made it clear that any patent must be licensed for everyone’s free use or not licensed at all.\n如果开发者需要使用和再发布，需要遵循的条款很多，下面列举几点比较重要的：\n\n\n\n\n\n\n\n\n\n\nThis License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License. The “Program”, below, refers to any such program or work, and a “work based on the Program” means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language. (Hereinafter, translation is included without limitation in the term “modification”.) Each licensee is addressed as “you”.Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program). Whether that is true depends on what the Program does.  \nYou may copy and distribute verbatim copies of the Program’s source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and give any other recipients of the Program a copy of this License along with the Program.You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.……\n\n\n任何引用、修改和翻译都需要告知版权方\n任何衍生品都需要保留源先的版权许可声明\n必须有条件的更改，使用等等\n\n有关于GPL协议比较有争议的还有GPL V2和V3修正版，有兴趣的同学可以自行查阅资料。我们熟知的遵循GPL协议的开源项目有鼎鼎大名的Linux，Proxysql等。\nLGPLLGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。 LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并 发布和销售。\n但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源 代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。\nGPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。我们熟知的遵循LGPL协议的开源项目有OpenPDF，echo3等\nMPLMozilla公共许可证（MPL），由Mozilla基金会开发维护。MPL出现的最重要原因就是，Netscape公司认为GPL没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。MPL再发布需要遵循以下几点：  \n\nMPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口。\nMPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序。\n对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利。\n对源代码的定义。在MPL（1.1版本）许可证中，对源代码的定义是:“源代码指的是对作品进行修改最优先择取的形式，它包括:所有模块的所有源程序，加上有关的接口的定义，加上控制可执行作品的安装和编译的‘原本’（原文为‘Script’），或者不是与初始源代码显著不同的源代码就是被源代码贡献者选择的从公共领域可以得到的程序代码。”\nMPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述\n\n我们熟知的遵循MPL协议的开源项目有Firefox，osbpm等\n其他除了上面几种比较著名的开源协议，还有许多比较特定的开源协议:  \n\nW3C：万网开源协议  \nPHP-3.0：PHP软件开源协议  \nNTP：网络时间协议……\n\n总结上面介绍的几种开源协议各有各的特点，相对于自由度来讲MIT具备更高的自由度，GPL对开源项目版权更加重视和保护。如果在选择使用开源项目时可能会根据实际情况进行更改，甚至可能后期售卖可以考虑Apache-2.0，BSD和MIT。如果仅仅是使用，并且可以参与到其建设，可以考虑选择GPL，LGP，MPL。如果是将自己的项目开源，并且给予广大开发者极大的权限，可以选择MIT，BSD。如果在开源项目的同时，想要保有自己的版权许可，可以选择Apache，GPL。当然，在现实环境中存在各种各样不确定因素，需要开发者们根据实际情况以及对应的法律条文进行选择，以上描述仅供参考。\n","slug":"开源协议对比/index","date":"2022-04-05T14:30:00.000Z","categories_index":"OSI","tags_index":"OSI","author_index":"Asura"}]
{"title":"Linux netfilter和iptables","uid":"5733706c6e3b1ed3f72bc107a7698f4a","slug":"Linux-netfilter和iptables","date":"2022-10-19T12:01:30.000Z","updated":"2022-10-31T02:30:24.284Z","comments":true,"path":"api/articles/Linux-netfilter和iptables.json","keywords":null,"cover":[],"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Netfilter是一个由Linux内核提供的框架，提供了一系列的hook，允许Linux内核模块注册为回调函数，Linux内核模块通过回调函数操作网络报文。<br>IPtables则是Linux的一个防火墙管理工具，可以很轻松的定义Linux网络数据包的过滤规则。这些定义的规则最终还是需要和Netfilter的hook交互来完成定义的数据包过滤工作。</p></blockquote>\n<div class=\"toc\">\n\n<!-- toc -->\n\n<ul>\n<li><a href=\"#netfilter\">Netfilter</a><ul>\n<li><a href=\"#jian-jie\">简介</a></li>\n<li><a href=\"#hooks\">Hooks</a></li>\n<li><a href=\"#shu-ju-bao-chu-li\">数据包处理</a><ul>\n<li><a href=\"#zhu-ce-netfilter-hook\">注册netfilter hook</a></li>\n<li><a href=\"#zhu-ce-han-shu-shi-xian\">注册函数实现</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#iptables\">Iptables</a><ul>\n<li><a href=\"#jian-jie-1\">简介</a></li>\n<li><a href=\"#gui-ze-biao\">规则表</a></li>\n<li><a href=\"#gui-ze-lian\">规则链</a></li>\n<li><a href=\"#chang-yong-fang-fa\">常用方法</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n\n</div>\n\n<h2><span id=\"netfilter\">Netfilter</span><a href=\"#netfilter\" class=\"header-anchor\">#</a></h2><h3><span id=\"jian-jie\">简介</span><a href=\"#jian-jie\" class=\"header-anchor\">#</a></h3><p>在开始了解Netfilter之前，我们先看一下一个网络数据包被接收的大致过程：<br><img src=\"../images/Linux-netfileter%E5%92%8Ciptables/dataflow.png\" alt=\"数据包\"></p>\n<ol>\n<li>数据包从网卡进来后由网卡驱动分配内存地址，通过DMA方式写入内存中，通过硬件中断（IRQ）通知CPU；</li>\n<li>CPU根据中断表调用已经注册的中断函数，通过中断函数调用驱动程序（NIC Driver），进入内核处理函数；</li>\n<li>在进入内核后调用协议栈对应的函数，将数据包交给协议栈处理；</li>\n<li>数据包经过ip_rcv入口函数筛选后调用注册在NF_INET_PRE_ROUTING Hook点上的函数；</li>\n<li>在经过黄色区域的规则处理之后，进入对应的协议层</li>\n</ol>\n<p>图中黄色区域就是Netfilter的过程，简单来讲，Netfilter是Linux内核提供的一套关于数据包的处理框架，提供了多个Hook点，可以允许在这些Hook点注册处理函数，在数据包经过这些Hook点的时候会调用这些注册函数对数据包进行处理。</p>\n<h3><span id=\"hooks\">Hooks</span><a href=\"#hooks\" class=\"header-anchor\">#</a></h3><p>Netfilter定义了以下Hook点：</p>\n<ul>\n<li>NF_INET_PRE_ROUTING</li>\n<li>NF_INET_LOCAL_IN</li>\n<li>NF_INET_FORWARD</li>\n<li>NF_INET_LOCAL_OUT</li>\n<li>NF_INET_POST_ROUTING</li>\n<li>NF_INET_NUMHOOKS</li>\n<li>NF_INET_INGRESS</li>\n</ul>\n<p>更多的定义可以参考<a href=\"https://elixir.bootlin.com/linux/v5.17.15/source/include/uapi/linux/netfilter.h\">netfilter.h</a></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">enum nf_inet_hooks &#123;\n\tNF_INET_PRE_ROUTING,\n\tNF_INET_LOCAL_IN,\n\tNF_INET_FORWARD,\n\tNF_INET_LOCAL_OUT,\n\tNF_INET_POST_ROUTING,\n\tNF_INET_NUMHOOKS,\n\tNF_INET_INGRESS &#x3D; NF_INET_NUMHOOKS,\n&#125;;</code></pre>\n\n<p>NF_INET_PRE_ROUTING: 数据包进入协议栈后首先会调用注册在这个Hook里的函数，在进行任何路由之前处理数据包。</p>\n<p>NF_INET_LOCAL_IN: 经过路由后的数据包如果指向的是本机，将会调用这个Hook里的函数。</p>\n<p>NF_INET_FORWARD: 经过路由后的数据包如果指向的是其他机器，将会调用这个Hook里的函数。</p>\n<p>NF_INET_LOCAL_OUT: 本机产生的数据包要发送到目的之前会立即调用这个Hook里的函数。</p>\n<p>NF_INET_POST_ROUTING: 本机产生的数据包要发送或者转发，在经过路由之后会调用这个Hook里的函数。</p>\n<h3><span id=\"shu-ju-bao-chu-li\">数据包处理</span><a href=\"#shu-ju-bao-chu-li\" class=\"header-anchor\">#</a></h3><h4><span id=\"zhu-ce-netfilter-hook\">注册netfilter hook</span><a href=\"#zhu-ce-netfilter-hook\" class=\"header-anchor\">#</a></h4><p>Netfilter在注册hook之前，需要将iptables规则转换为对应的nf_hook_ops变量，然后注册</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">struct nf_hook_ops &#123;\n\t&#x2F;* User fills in from here down. *&#x2F;\n\tnf_hookfn\t\t    *hook;\n\tstruct net_device\t*dev;\n\tvoid\t\t\t    *priv;\n\tu8\t   pf;\n\tenum   nf_hook_ops_type\thook_ops_type:8;\n\tunsigned int\t\thooknum;\n\t&#x2F;* Hooks are ordered in ascending priority. *&#x2F;\n\tint\t\t\tpriority;\n&#125;;</code></pre>\n<ul>\n<li>nf_bookfn: 定义了一个函数指针，数据包在经过Hook点的时候会调用这个函数</li>\n<li>net_device: 网络设备，可以根据数据包的原接口和目的接口筛选相应的数据包</li>\n<li>pf: 指定协议族</li>\n<li>hooknum: 指定函数对应的Hook类型</li>\n<li>priority: 规定了函数执行顺序</li>\n</ul>\n<p>通过调用nf_register_net_hook()或者nf_register_net_hooks()函数注册Netfilter hook函数，并返回一个整形</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">int nf_register_net_hook(struct net *net, const struct nf_hook_ops *reg)\n&#123;\n\tint err;\n\n\tif (reg-&gt;pf &#x3D;&#x3D; NFPROTO_INET) &#123;\n\t\tif (reg-&gt;hooknum &#x3D;&#x3D; NF_INET_INGRESS) &#123;\n\t\t\terr &#x3D; __nf_register_net_hook(net, NFPROTO_INET, reg);\n\t\t\tif (err &lt; 0)\n\t\t\t\treturn err;\n\t\t&#125; else &#123;\n\t\t\terr &#x3D; __nf_register_net_hook(net, NFPROTO_IPV4, reg);\n\t\t\tif (err &lt; 0)\n\t\t\t\treturn err;\n\n\t\t\terr &#x3D; __nf_register_net_hook(net, NFPROTO_IPV6, reg);\n\t\t\tif (err &lt; 0) &#123;\n\t\t\t\t__nf_unregister_net_hook(net, NFPROTO_IPV4, reg);\n\t\t\t\treturn err;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125; else &#123;\n\t\terr &#x3D; __nf_register_net_hook(net, reg-&gt;pf, reg);\n\t\tif (err &lt; 0)\n\t\t\treturn err;\n\t&#125;\n\n\treturn 0;\n&#125;\nEXPORT_SYMBOL(nf_register_net_hook);\n\nint nf_register_net_hooks(struct net *net, const struct nf_hook_ops *reg,\n\t\t\t  unsigned int n)\n&#123;\n\tunsigned int i;\n\tint err &#x3D; 0;\n\n\tfor (i &#x3D; 0; i &lt; n; i++) &#123;\n\t\terr &#x3D; nf_register_net_hook(net, &amp;reg[i]);\n\t\tif (err)\n\t\t\tgoto err;\n\t&#125;\n\treturn err;\n\nerr:\n\tif (i &gt; 0)\n\t\tnf_unregister_net_hooks(net, reg, i);\n\treturn err;\n&#125;\nEXPORT_SYMBOL(nf_register_net_hooks);\n</code></pre>\n\n<p>通过调用nf_unregister_net_hook()或者nf_unregister_net_hooks()注销Netfilter Hook函数</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">void nf_unregister_net_hook(struct net *net, const struct nf_hook_ops *reg)\n&#123;\n\tif (reg-&gt;pf &#x3D;&#x3D; NFPROTO_INET) &#123;\n\t\tif (reg-&gt;hooknum &#x3D;&#x3D; NF_INET_INGRESS) &#123;\n\t\t\t__nf_unregister_net_hook(net, NFPROTO_INET, reg);\n\t\t&#125; else &#123;\n\t\t\t__nf_unregister_net_hook(net, NFPROTO_IPV4, reg);\n\t\t\t__nf_unregister_net_hook(net, NFPROTO_IPV6, reg);\n\t\t&#125;\n\t&#125; else &#123;\n\t\t__nf_unregister_net_hook(net, reg-&gt;pf, reg);\n\t&#125;\n&#125;\nEXPORT_SYMBOL(nf_unregister_net_hook);\n\nvoid nf_unregister_net_hooks(struct net *net, const struct nf_hook_ops *reg,\n\t\t\t     unsigned int hookcount)\n&#123;\n\tunsigned int i;\n\n\tfor (i &#x3D; 0; i &lt; hookcount; i++)\n\t\tnf_unregister_net_hook(net, &amp;reg[i]);\n&#125;\nEXPORT_SYMBOL(nf_unregister_net_hooks);</code></pre>\n\n<h4><span id=\"zhu-ce-han-shu-shi-xian\">注册函数实现</span><a href=\"#zhu-ce-han-shu-shi-xian\" class=\"header-anchor\">#</a></h4><p>下面是一个简单的例子</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">#include &lt;linux&#x2F;kernel.h&gt;\n#include &lt;linux&#x2F;init.h&gt;\n#include &lt;linux&#x2F;module.h&gt;\n#include &lt;linux&#x2F;version.h&gt;\n#include &lt;linux&#x2F;skbuff.h&gt;\n#include &lt;linux&#x2F;netfilter.h&gt;\n#include &lt;linux&#x2F;netfilter_ipv4.h&gt;\n \nMODULE_LICENSE(&quot;GPL&quot;);\nMODULE_AUTHOR(&quot;xsc&quot;);\n \nstatic struct nf_hook_ops nfho;\n \nunsigned int hook_func(unsigned int hooknum,\n                       struct sk_buff *skb,\n                       const struct net_device *in,\n                       const struct net_device *out,\n                       int (*okfn)(struct sk_buff *))\n&#123;\n\treturn NF_DROP;\n&#125;\n \nstatic int kexec_test_init(void)\n&#123;\n \n    nfho.hook &#x3D; hook_func;\n    nfho.owner &#x3D; NULL;\n    nfho.pf &#x3D; PF_INET;\n    nfho.hooknum &#x3D; NF_INET_LOCAL_OUT;\n    nfho.priority &#x3D; NF_IP_PRI_FIRST;\n    \n    nf_register_net_hook(&amp;nfho);\n    return 0;\n&#125;\n \nstatic void kexec_test_exit(void)\n&#123;\n    nf_unregister_net_hook(&amp;nfho);\n&#125;\n \nmodule_init(kexec_test_init);\nmodule_exit(kexec_test_exit);</code></pre>\n\n<h2><span id=\"iptables\">Iptables</span><a href=\"#iptables\" class=\"header-anchor\">#</a></h2><h3><span id=\"jian-jie\">简介</span><a href=\"#jian-jie\" class=\"header-anchor\">#</a></h3><p>Netfilter提供了Hook点允许在数据包处理过程中注册执行函数，Iptables则是一个工具让用户轻松定义处理规则并转换为执行函数注册到Netfilter对应的Hook点。<br>规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。<br><img src=\"../images/Linux-netfileter%E5%92%8Ciptables/iptables.png\" alt=\"iptables\"></p>\n<h3><span id=\"gui-ze-biao\">规则表</span><a href=\"#gui-ze-biao\" class=\"header-anchor\">#</a></h3><p>Iptables内置了四个规则表</p>\n<ul>\n<li>filter表：用于过滤数据包，决定是否放行（DROP，ACCEPT，REJECT，LOG），包含三个链-INPUT，FORWARD，OUTPUT</li>\n<li>nat表：用于数据包IP，端口转换（SNAT，DNAT，MASQUERADE，REDIRECT），包含三个链-PREROUTING，OUTPUT，POSTROUTING</li>\n<li>mangle表：主要用于修改数据包的服务类型（TOS），生存周期（TTL）以及为数据包设置MARK以实现服务质量（Qos）调整及策略路由，包含五个链-PREROUTING，POSTROUTING，INPUT，OUTPUT，FORWARD</li>\n<li>raw表：主要用于决定数据包是否被状态跟踪机制处理。raw表的规则要优先于其他表，包含两条链-OUTPUT，PREROUTING</li>\n</ul>\n<p>规则表优先顺序：<br>raw表&gt;&gt;&gt;mangle&gt;&gt;&gt;nat&gt;&gt;&gt;filter</p>\n<h3><span id=\"gui-ze-lian\">规则链</span><a href=\"#gui-ze-lian\" class=\"header-anchor\">#</a></h3><p>Iptables的规则链对应的是Netfilter里的hook点，分别是：</p>\n<ul>\n<li>PREROUTING：在数据包路由之前执行这条链中注册的规则</li>\n<li>INPUT：对经过路由选择后流向本地的数据包执行这条链中的规则</li>\n<li>OUTPUT：对将要发送的数据包执行这条链中的规则</li>\n<li>FORWART：对经过路由选择后转发的数据包执行这条链中的规则</li>\n<li>POSTROUTING：对发送的数据包执行这条链中的规则</li>\n</ul>\n<h3><span id=\"chang-yong-fang-fa\">常用方法</span><a href=\"#chang-yong-fang-fa\" class=\"header-anchor\">#</a></h3><p>Iptables的帮助信息<br><img src=\"../images/Linux-netfileter%E5%92%8Ciptables/help.png\" alt=\"help\"></p>\n<ol>\n<li><p>查看规则  </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 查看所有规则\n&#x2F; # iptables -L</code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 查看具体表中规则\n&#x2F; # iptables -L -t raw</code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 以ip和端口形式展示\n&#x2F; # iptables -L -n</code></pre>\n</li>\n<li><p>修改规则  </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 添加规则\n&#x2F; # iptables -A INPUT -p tcp -s 192.168.0.0&#x2F;24 -j ACCEPT</code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 删除规则\n&#x2F; # iptables -D INPUT -s 192.168.0.0&#x2F;24 -j ACCEPT</code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 清空规则\n&#x2F; # iptables -F</code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 修改规则\n&#x2F; # iptables -P OUTPUT DROP</code></pre></li>\n</ol>\n","feature":true,"text":" Netfilter是一个由Linux内核提供的框架，提供了一系列的hook，允许Linux内核模块注册为回调函数，Linux内核模块通过回调函数操作网络报文。IPtables则是Linux的一个防火墙管理工具，可以很轻松的定义Linux网络数据包的过滤规则。这些定义的规则最终还...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Linux","slug":"Linux","count":3,"path":"api/tags/Linux.json"},{"name":"Netfilter","slug":"Netfilter","count":1,"path":"api/tags/Netfilter.json"},{"name":"Iptables","slug":"Iptables","count":1,"path":"api/tags/Iptables.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Netfilter</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Hooks</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">数据包处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">注册netfilter hook</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">注册函数实现</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Iptables</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">规则表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">规则链</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">常用方法</span></a></li></ol></li></ol>","author":{"name":"Asura","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Keep runnig!","socials":{"github":"https://github.com/G-Asura","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"使用Nocalhost在Kubernetes中调试代码","uid":"0deca7558ba6f9defe92ca748e91351a","slug":"使用Nocalhost在Kubernetes中调试代码","date":"2022-10-10T12:10:41.000Z","updated":"2022-10-19T02:04:16.638Z","comments":true,"path":"api/articles/使用Nocalhost在Kubernetes中调试代码.json","keywords":null,"cover":[],"text":" 云原生开发工程师在日常开发中会经常遇到需要操作或者连接Kubernetes集群中的资源，但是往往本地开发环境和Kubernetes集群之间网络不通，这时调试代码就会十分不方便，所以有时我们需要在Kubernetes集群中进行代码调试，下面就是基于Nocalhost的一种在Kub...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"Tools","slug":"Tools","count":1,"path":"api/categories/Tools.json"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","count":2,"path":"api/tags/Kubernetes.json"},{"name":"Nocalhost","slug":"Nocalhost","count":1,"path":"api/tags/Nocalhost.json"},{"name":"IDE","slug":"IDE","count":1,"path":"api/tags/IDE.json"}],"author":{"name":"Asura","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Keep runnig!","socials":{"github":"https://github.com/G-Asura","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}
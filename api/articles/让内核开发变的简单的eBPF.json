{"title":"让内核开发变的简单的eBPF","uid":"8b17daa7707d9d476a6f46015ac8ef41","slug":"让内核开发变的简单的eBPF","date":"2022-04-10T12:43:44.000Z","updated":"2022-04-12T14:15:06.579Z","comments":true,"path":"api/articles/让内核开发变的简单的eBPF.json","keywords":null,"cover":[],"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>eBPF 是一项革命性的技术，起源于 Linux 内核，可以在操作系统内核中运行沙盒程序。它用于安全有效地扩展内核的功能，而无需更改内核源代码或加载内核模块。</p></blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">eBPF is a revolutionary technology with origins in the Linux kernel that can run sandboxed programs in an operating system kernel. It is used to safely and efficiently extend the capabilities of the kernel without requiring to change kernel source code or load kernel modules.</code></pre>\n\n<div class=\"toc\">\n\n<!-- toc -->\n\n<ul>\n<li><a href=\"#fa-zhan-li-cheng\">发展历程</a><ul>\n<li><a href=\"#you-lai\">由来</a><ul>\n<li><a href=\"#bpf\">BPF</a></li>\n<li><a href=\"#ebpf\">eBPF</a></li>\n<li><a href=\"#bpf-vs-ebpf\">BPF VS eBPF</a></li>\n</ul>\n</li>\n<li><a href=\"#fa-zhan-li-cheng-1\">发展历程</a></li>\n</ul>\n</li>\n<li><a href=\"#chong-yao-zhi-shi-dian\">重要知识点</a><ul>\n<li><a href=\"#hook-overview\">Hook Overview</a></li>\n<li><a href=\"#verifier\">Verifier</a></li>\n<li><a href=\"#jit\">JIT</a></li>\n<li><a href=\"#maps\">Maps</a></li>\n<li><a href=\"#diao-yong-ji-zhi\">调用机制</a><ul>\n<li><a href=\"#helper-calls\">Helper Calls</a></li>\n<li><a href=\"#tailcalls\">TailCalls</a></li>\n<li><a href=\"#bpf-to-bpf-calls\">BPF to BPF Calls</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#ebpf-gao-ji-shi-xian-bpftrace\">eBPF高级实现bpftrace</a><ul>\n<li><a href=\"#bpftrace-an-zhuang\">bpftrace安装</a></li>\n<li><a href=\"#bpftrace-shi-yong\">bpftrace使用</a></li>\n</ul>\n</li>\n<li><a href=\"#can-kao-wen-dang\">参考文档</a></li>\n</ul>\n<!-- tocstop -->\n\n</div>\n\n<h2><span id=\"fa-zhan-li-cheng\">发展历程</span><a href=\"#fa-zhan-li-cheng\" class=\"header-anchor\">#</a></h2><h3><span id=\"you-lai\">由来</span><a href=\"#you-lai\" class=\"header-anchor\">#</a></h3><p>我们先从eBPF的发展历程开始了解eBPF。了解一下eBPF是怎么一步步重新定义了数据面（datapath）的。  </p>\n<h4><span id=\"bpf\">BPF</span><a href=\"#bpf\" class=\"header-anchor\">#</a></h4><p>说到eBPF，首先必须要提的就是它的前身BPF，即BPF（Berkeley Packet Filter ），中文翻译为伯克利包过滤器，是类 Unix 系统上数据链路层的一种原始接口，提供原始链路层封包的收发。<br>BPF在数据包过滤上开创性的引入了两大革新：  </p>\n<ul>\n<li>一个新的虚拟机 (VM) 设计，可以有效地工作在基于寄存器结构的 CPU 之上；</li>\n<li>应用程序使用缓存只复制与过滤数据包相关的数据，不会复制数据包的所有信息。这样可以最大程度地减少BPF 处理的数据<br>这两项革新技术也使得数据包过滤技术比当时最先进的技术快20倍。我们熟知的tcpdump就是BPF的具体实现。  </li>\n</ul>\n<h4><span id=\"ebpf\">eBPF</span><a href=\"#ebpf\" class=\"header-anchor\">#</a></h4><p>在2014年初，在eBPF的第一个patch被拒后的下一年，第一个eBPF patch合并到了内核，从此开启了eBPF的纪元，巧合的是同年Kubernetes也在这一年提交了第一个commit。<br>eBPF（extended Berkeley Packet Filter），即扩展的伯克利包过滤器。<br>eBPF最早出现在3.18内核中，从这以后BPF就被称为经典的BPF，即cBPF（classic BPF）。<br>eBPF的特点有以下几点：</p>\n<ul>\n<li>不能crash内核（最重要的一点）</li>\n<li>执行起来与内核模块一样快</li>\n<li>提供稳定的API</li>\n</ul>\n<h4><span id=\"bpf-vs-ebpf\">BPF VS eBPF</span><a href=\"#bpf-vs-ebpf\" class=\"header-anchor\">#</a></h4><table>\n<thead>\n<tr>\n<th align=\"left\">维度</th>\n<th align=\"left\">cBPF</th>\n<th align=\"left\">eBPF</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">内核版本</td>\n<td align=\"left\">Linux 2.1.75（1997年）</td>\n<td align=\"left\">Linux 3.18（2014年）[4.x for kprobe/uprobe/tracepoint/perf-event]</td>\n</tr>\n<tr>\n<td align=\"left\">寄存器数目</td>\n<td align=\"left\">2个：A, X</td>\n<td align=\"left\">10个： R0–R9, 另外 R10 是一个只读的帧指针</td>\n</tr>\n<tr>\n<td align=\"left\">寄存器宽度</td>\n<td align=\"left\">32位</td>\n<td align=\"left\">64位</td>\n</tr>\n<tr>\n<td align=\"left\">存储</td>\n<td align=\"left\">16 个内存位: M[0–15]</td>\n<td align=\"left\">512 字节堆栈，无限制大小的 “map” 存储</td>\n</tr>\n<tr>\n<td align=\"left\">限制的内核调用</td>\n<td align=\"left\">非常有限，仅限于 JIT 特定</td>\n<td align=\"left\">有限，通过 bpf_call 指令调用</td>\n</tr>\n<tr>\n<td align=\"left\">目标事件</td>\n<td align=\"left\">数据包、 seccomp-BPF</td>\n<td align=\"left\">数据包、内核函数、用户函数、跟踪点 PMCs 等</td>\n</tr>\n</tbody></table>\n<h3><span id=\"fa-zhan-li-cheng\">发展历程</span><a href=\"#fa-zhan-li-cheng\" class=\"header-anchor\">#</a></h3><p>我们可以通过下面RoadMap看到eBPF的发展历程：  </p>\n<p><img src=\"../images/%E8%AE%A9%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E5%8F%98%E7%9A%84%E7%AE%80%E5%8D%95%E7%9A%84eBPF/roadmap.png\" alt=\"eBPF RoadMap\"></p>\n<ul>\n<li>2013年<br>这个时期有OpenvSwitch（OVS）、tc（Traffic control），以及内核子系统Netfilter(包括iptables、ipvs、nftables工具)，可以用来对datapath进行“编程”。<br>同时期的tcpdump应用BPF在内核前端位置进行抓包。<br>在这种非常限制的情况下，eBPF以能够创建新的datapath的特性提了一个“巨型”patch，然而因为侵入性太强遭拒。</li>\n<li>2014年<br>第一个eBPF patch合并到内核。<br>用一个扩展的指令集逐步替换原来老的BPF解释器，实现了自动新老BPF转换(in-kernel translation)。后续patch将eBPF暴露给UAPI，并添加了verifier代码和JIT代码。</li>\n<li>2015年<br>eBPF分成了两个方向： networking和tracing。<br>eBPF backend合并到LLVM 3.7。<br>支持将eBPF attach到kprobes。<br>通过cls_bpf使tc子系统可编程，为tc添加了一个lockless ingress和egress hook点。<br>eBPF tracing项目bcc发布。</li>\n<li>2016年<br>eBPF添加了一个新fast path: XDP，并合并到内核，支持驱动的ingress层attach BPF程序。<br>Cilium项目发布。  </li>\n<li>2017年<br>eBPF开始大规模应用于生产环境，如Netflix,facebook, Cloudflare等。<br>添加BPF函数调用。<br>提供了用户态依赖库libbpf。<br>eBPF成为内核独立子系统。  </li>\n<li>2018年<br>Cilium 1.0发布，标记着eBPF开始影响到K8S领域。  </li>\n<li>2019年<br>bpftrace发布。<br>BPF backend合并到GCC，至此，GCC和LLVM都支持了BPF backend。<br>Cilium 1.6发布，第一次支持完全干掉基于iptables的kube-proxy  </li>\n<li>2020年<br>Cilium 1.8发布，支持基于XDP的Service负载均衡和host network policies。<br>eBPF在Linux security modules上开始发力。  </li>\n</ul>\n<h2><span id=\"chong-yao-zhi-shi-dian\">重要知识点</span><a href=\"#chong-yao-zhi-shi-dian\" class=\"header-anchor\">#</a></h2><p>在我开始了解eBPF知识之前，先来看看eBPF架构图</p>\n<p><img src=\"../images/%E8%AE%A9%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E5%8F%98%E7%9A%84%E7%AE%80%E5%8D%95%E7%9A%84eBPF/%E6%9E%B6%E6%9E%84%E5%9B%BE.png\" alt=\"eBPF架构图\"></p>\n<p>从架构图中可以看出用户空间程序与内核中的BPF字节码交互的流程主要如下：  </p>\n<ul>\n<li>使用 LLVM 或者 GCC 工具将编写的 BPF 代码程序编译成 BPF 字节码；   </li>\n<li>使用加载程序 Loader 将字节码加载至内核；  </li>\n<li>内核使用验证器（Verfier） 组件保证执行字节码的安全性，以避免对内核造成灾难，在确认字节码安全后将其加载对应的内核模块执行；   </li>\n<li>内核中运行的 BPF 字节码程序可以使用两种方式将数据回传至用户空间：  <ul>\n<li>maps 方式可用于将内核中实现的统计摘要信息（比如测量延迟、堆栈信息）等回传至用户空间；  </li>\n<li>perf-event 用于将内核采集的事件实时发送至用户空间，用户空间程序实时读取分析；<br>接下来我们来了解一下这其中的相关技术。  </li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"hook-overview\">Hook Overview</span><a href=\"#hook-overview\" class=\"header-anchor\">#</a></h3><p>Linux Hook技术主要有四种：  </p>\n<ul>\n<li>内核模块hook</li>\n<li>应用层inline hook</li>\n<li>应用层Got hook</li>\n<li>应用层preload hook</li>\n</ul>\n<p>而BPF hook是Linux内核众多hook点中的一类。eBPF 程序都是事件驱动的，它们会在内核或者应用程序经过某个确定的 Hook 点的时候运行，这些 Hook 点都是提前定义的，包括系统调用、函数进入/退出、内核 tracepoints、网络事件等。<br>如果针对某个特定需求的 Hook 点不存在，可以通过 kprobe 或者 uprobe 来在内核或者用户程序的几乎所有地方挂载 eBPF 程序。<br>更多Hook信息可以看<a href=\"https://elixir.bootlin.com/linux/v5.17.2/source/kernel/bpf/syscall.c\">这里</a>。</p>\n<h3><span id=\"verifier\">Verifier</span><a href=\"#verifier\" class=\"header-anchor\">#</a></h3><p>eBPF程序能挂载在内核的大部分地方，这样带来的风险是及其巨大的，如果程序不正确极有可能导致内核崩溃，这时一种可靠的校验是十分重要的。<br>Verifier就是那个强大的保障，保证每个eBPF程序加载到内核之前都是正确和安全的，主要校验以下几点：  </p>\n<ul>\n<li>要保证 加载 eBPF 程序的进程有必要的特权级，除非节点开启了 unpriviledged 特性，只有特权级的程序才能够加载 eBPF 程序  <ul>\n<li>内核提供了一个配置项 /proc/sys/kernel/unprivileged_bpf_disabled 来禁止非特权用户使用 bpf(2) 系统调用，可以通过 sysctl 命令修改  </li>\n<li>比较特殊的一点是，这个配置项特意设计为一次性开关（one-time kill switch）， 这意味着一旦将它设为 1，就没有办法再改为 0 了，除非重启内核  </li>\n<li>一旦设置为 1 之后，只有初始命名空间中有 CAP_SYS_ADMIN 特权的进程才可以调用 bpf(2) 系统调用 。Cilium 启动后也会将这个配置项设为 1：</li>\n</ul>\n</li>\n<li>要保证 eBPF 程序不会崩溃或者使得系统出故障</li>\n<li>要保证 eBPF 程序不能陷入死循环，能够 runs to completion</li>\n<li>要保证 eBPF 程序必须满足系统要求的大小，过大的 eBPF 程序不允许被加载进内核</li>\n<li>要保证 eBPF 程序的复杂度有限，Verifier 将会评估 eBPF 程序所有可能的执行路径，必须能够在有限时间内完成 eBPF 程序复杂度分析  </li>\n</ul>\n<h3><span id=\"jit\">JIT</span><a href=\"#jit\" class=\"header-anchor\">#</a></h3><p>Just-In-Time(JIT) 编译用来将通用的 eBPF 字节码翻译成与机器相关的指令集，从而极大加速 BPF 程序的执行：  </p>\n<ul>\n<li>与解释器相比，它们可以降低每个指令的开销。通常，指令可以 1:1 映射到底层架构的原生指令  </li>\n<li>这也会减少生成的可执行镜像的大小，因此对 CPU 的指令缓存更友好  </li>\n<li>特别地，对于 CISC 指令集（例如 x86），JIT 做了很多特殊优化，目的是为给定的指令产生可能的最短操作码，以降低程序翻译过程所需的空间<br>64 位的 x86_64、arm64、ppc64、s390x、mips64、sparc64 和 32 位的 arm 、x86_32 架构都内置了 in-kernel eBPF JIT 编译器，它们的功能都是一样的，可以用如下方式打开：<br><code>$ echo 1 &gt; /proc/sys/net/core/bpf_jit_enable</code></li>\n</ul>\n<p>32 位的 mips、ppc 和 sparc 架构目前内置的是一个 cBPF JIT 编译器。这些只有 cBPF JIT 编译器的架构，以及那些甚至完全没有 BPF JIT 编译器的架构，需要通过内核中的解释器（in-kernel interpreter）执行 eBPF 程序。  </p>\n<h3><span id=\"maps\">Maps</span><a href=\"#maps\" class=\"header-anchor\">#</a></h3><p>Map是内核中用来保存信息的重要数据结构，BPF自然也有属于自己的Map数据结构。<br>BPF Map 是驻留在内核空间中的高效 Key/Value store，包含多种类型的 Map，由内核实现其功能。<br>BPF Map 的交互场景有以下几种：  </p>\n<ul>\n<li>BPF 程序和用户态程序的交互：BPF 程序运行完，得到的结果存储到 map 中，供用户态程序通过文件描述符访问  </li>\n<li>BPF 程序和内核态程序的交互：和 BPF 程序以外的内核程序交互，也可以使用 map 作为中介  </li>\n<li>BPF 程序间交互：如果 BPF 程序内部需要用全局变量来交互，但是由于安全原因 BPF 程序不允许访问全局变量，可以使用 map 来充当全局变量  </li>\n<li>BPF Tail call：Tail call 是一个 BPF 程序跳转到另一 BPF 程序，BPF 程序首先通过 BPF_MAP_TYPE_PROG_ARRAY 类型的 map 来知道另一个 BPF 程序的指针，然后调用 tail_call() 的 helper function 来执行 Tail call  </li>\n</ul>\n<p>共享 map 的 BPF 程序不要求是相同的程序类型，例如 tracing 程序可以和网络程序共享 map，单个 BPF 程序目前最多可直接访问 64 个不同 map。</p>\n<p>当前可用的 通用 map 有：  </p>\n<ul>\n<li>BPF_MAP_TYPE_HASH  </li>\n<li>BPF_MAP_TYPE_ARRAY  </li>\n<li>BPF_MAP_TYPE_PERCPU_HASH  </li>\n<li>BPF_MAP_TYPE_PERCPU_ARRAY  </li>\n<li>BPF_MAP_TYPE_LRU_HASH  </li>\n<li>BPF_MAP_TYPE_LRU_PERCPU_HASH  </li>\n<li>BPF_MAP_TYPE_LPM_TRIE  </li>\n</ul>\n<p>以上 map 都使用相同的一组 BPF 辅助函数来执行查找、更新或删除操作，但各自实现了不同的后端，这些后端各有不同的语义和性能特点。随着多 CPU 架构的成熟发展，BPF Map 也引入了 per-cpu 类型，如BPF_MAP_TYPE_PERCPU_HASH、BPF_MAP_TYPE_PERCPU_ARRAY等，当你使用这种类型的 BPF Map 时，每个 CPU 都会存储并看到它自己的 Map 数据，从属于不同 CPU 之间的数据是互相隔离的，这样做的好处是，在进行查找和聚合操作时更加高效，性能更好，尤其是你的 BPF 程序主要是在做收集时间序列型数据，如流量数据或指标等。</p>\n<p>当前内核中的 非通用 map 有：  </p>\n<ul>\n<li>BPF_MAP_TYPE_PROG_ARRAY：一个数组 map，用于 hold 其他的 BPF 程序</li>\n<li>BPF_MAP_TYPE_PERF_EVENT_ARRAY  </li>\n<li>BPF_MAP_TYPE_CGROUP_ARRAY：用于检查 skb 中的 cgroup2 成员信息  </li>\n<li>BPF_MAP_TYPE_STACK_TRACE：用于存储栈跟踪的 MAP  </li>\n<li>BPF_MAP_TYPE_ARRAY_OF_MAPS：持有（hold） 其他 map 的指针，这样整个 map 就可以在运行时实现原子替换  </li>\n<li>BPF_MAP_TYPE_HASH_OF_MAPS：持有（hold） 其他 map 的指针，这样整个 map 就可以在运行时实现原子替换  </li>\n</ul>\n<h3><span id=\"diao-yong-ji-zhi\">调用机制</span><a href=\"#diao-yong-ji-zhi\" class=\"header-anchor\">#</a></h3><h4><span id=\"helper-calls\">Helper Calls</span><a href=\"#helper-calls\" class=\"header-anchor\">#</a></h4><p>eBPF程序不能够随意调用内核函数，如果这么做的话会导致 eBPF 程序与特定的内核版本绑定，相反它内核定义的一系列 Helper functions。Helper functions 使得 BPF 能够通过一组内核定义的稳定的函数调用来从内核中查询数据，或者将数据推送到内核。  </p>\n<h4><span id=\"tailcalls\">TailCalls</span><a href=\"#tailcalls\" class=\"header-anchor\">#</a></h4><p>尾调用的机制是指：一个 BPF 程序可以调用另一个 BPF 程序，并且调用完成后不用返回到原来的程序。  </p>\n<ul>\n<li>和普通函数调用相比，这种调用方式开销最小，因为它是用长跳转（long jump）实现的，复用了原来的栈帧 （stack frame）  </li>\n<li>BPF 程序都是独立验证的，因此要传递状态，要么使用 per-CPU map 作为 scratch 缓冲区 ，要么如果是 tc 程序的话，还可以使用 skb 的某些字段（例如 cb[]）  </li>\n<li>相同类型的程序才可以尾调用，而且它们还要与 JIT 编译器相匹配，因此要么是 JIT 编译执行，要么是解释器执行（invoke interpreted programs），但不能同时使用两种方式  </li>\n</ul>\n<h4><span id=\"bpf-to-bpf-calls\">BPF to BPF Calls</span><a href=\"#bpf-to-bpf-calls\" class=\"header-anchor\">#</a></h4><p>除了 BPF 辅助函数和 BPF 尾调用之外，BPF 核心基础设施最近刚加入了一个新特性：BPF to BPF calls。<br>当 LLVM 编译和生成 BPF 对象文件时，所有这些函数将被内联，因此会在生成的对象文件中重 复多次，导致代码尺寸膨胀。<br>BPF 到 BPF 调用是一个重要的性能优化，极大减小了生成的 BPF 代码大小，因此 对 CPU 指令缓存（instruction cache，i-cache）更友好。</p>\n<h2><span id=\"ebpf-gao-ji-shi-xian-bpftrace\">eBPF高级实现bpftrace</span><a href=\"#ebpf-gao-ji-shi-xian-bpftrace\" class=\"header-anchor\">#</a></h2><p>BPFTrace 是基于 BPF 和 BCC 的开源项目，与 BCC 不同的是其提供了更高层次的抽象，可以使用类似 AWK 脚本语言来编写基于 BPF 的跟踪或者性能排查工具，更加易于入门和编写，该工具的主要灵感来自于 Solaris 的 D 语言。BPFTrace 更方便与编写单行的程序。</p>\n<h3><span id=\"bpftrace-an-zhuang\">bpftrace安装</span><a href=\"#bpftrace-an-zhuang\" class=\"header-anchor\">#</a></h3><p>bpftrace支持多种安装方式，具体安装步骤可以看<a href=\"https://github.com/iovisor/bpftrace/blob/master/INSTALL.md\">这里</a>。  </p>\n<h3><span id=\"bpftrace-shi-yong\">bpftrace使用</span><a href=\"#bpftrace-shi-yong\" class=\"header-anchor\">#</a></h3><ul>\n<li><p>根据不同的tracepoint查看：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 统计进程调用sys_enter的次数\nbpftrace -e &#39;tracepoint:raw_syscalls:sys_enter &#123; @[comm] &#x3D; count(); &#125;&#39;</code></pre>\n\n<p><img src=\"../images/%E8%AE%A9%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E5%8F%98%E7%9A%84%E7%AE%80%E5%8D%95%E7%9A%84eBPF/bpftrace1.png\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 统计内核中函数堆栈的次数\nbpftrace -e &#39;profile:hz:99 &#123; @[kstack] &#x3D; count(); &#125;&#39;</code></pre>\n<p><img src=\"../images/%E8%AE%A9%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E5%8F%98%E7%9A%84%E7%AE%80%E5%8D%95%E7%9A%84eBPF/bpftrace2.png\"></p>\n</li>\n<li><p>还可以使用内部脚本进行追踪：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># \b内核函数调用情况查看\n.&#x2F;tools&#x2F;syscount.bt</code></pre>\n<p><img src=\"../images/%E8%AE%A9%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E5%8F%98%E7%9A%84%E7%AE%80%E5%8D%95%E7%9A%84eBPF/bpftrace3.png\"></p>\n<h2><span id=\"can-kao-wen-dang\">参考文档</span><a href=\"#can-kao-wen-dang\" class=\"header-anchor\">#</a></h2><ul>\n<li><a href=\"https://ebpf.io/what-is-ebpf#hook-overview\">https://ebpf.io/what-is-ebpf#hook-overview</a></li>\n<li><a href=\"https://cloudnative.to/blog/bpf-intro/#43-bpftrace\">https://cloudnative.to/blog/bpf-intro/#43-bpftrace</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/zCjk5WmnwLD0J3J9gC4e0Q\">https://mp.weixin.qq.com/s/zCjk5WmnwLD0J3J9gC4e0Q</a></li>\n</ul>\n</li>\n</ul>\n","feature":true,"text":" eBPF 是一项革命性的技术，起源于 Linux 内核，可以在操作系统内核中运行沙盒程序。它用于安全有效地扩展内核的功能，而无需更改内核源代码或加载内核模块。 eBPF is a revolutionary technology with origins in the Linu...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"eBPF","slug":"eBPF","count":2,"path":"api/categories/eBPF.json"}],"tags":[{"name":"eBPF","slug":"eBPF","count":2,"path":"api/tags/eBPF.json"},{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">发展历程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">由来</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">BPF</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">eBPF</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">BPF VS eBPF</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">发展历程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">重要知识点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Hook Overview</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Verifier</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">JIT</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Maps</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">调用机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">Helper Calls</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">TailCalls</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">BPF to BPF Calls</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">eBPF高级实现bpftrace</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">bpftrace安装</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">bpftrace使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">参考文档</span></a></li></ol>","author":{"name":"Asura","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Keep runnig!","socials":{"github":"https://github.com/G-Asura","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Cilium实现原理","uid":"65501d6a3eead0987c9f5d07b63371fd","slug":"Cilium实现原理","date":"2022-04-12T14:09:25.000Z","updated":"2022-04-12T18:00:18.905Z","comments":true,"path":"api/articles/Cilium实现原理.json","keywords":null,"cover":[],"text":" Cilium是eBPF网络分支的明星项目，Cilium的发布也意味着eBPF开始向K8S领域进军。 Cilium eBPF流程 流程图 Agent启动原理 入口函数 数据路径 kube-proxy包转发路径 Cilium eBPF包转发路径 演示 Cilium eBPF流程#了...","link":"","photos":[],"count_time":{"symbolsCount":"48k","symbolsTime":"44 mins."},"categories":[{"name":"eBPF","slug":"eBPF","count":2,"path":"api/categories/eBPF.json"}],"tags":[{"name":"CNI","slug":"CNI","count":1,"path":"api/tags/CNI.json"},{"name":"eBPF","slug":"eBPF","count":2,"path":"api/tags/eBPF.json"},{"name":"Kubernetes","slug":"Kubernetes","count":1,"path":"api/tags/Kubernetes.json"}],"author":{"name":"Asura","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Keep runnig!","socials":{"github":"https://github.com/G-Asura","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Prometheus数据流","uid":"78cf92f2c0639bec80519c22649cfa6b","slug":"Prometheus数据流","date":"2022-04-08T08:46:07.000Z","updated":"2022-04-12T04:20:58.958Z","comments":true,"path":"api/articles/Prometheus数据流.json","keywords":null,"cover":[],"text":" Prometheus是一个开源的监控和报警工具。它优秀的设计理念，灵活的扩展，丰富的生态以及活跃的社区使它正在成为众多开发者喜爱的监控工具。 简介 数据拉取 Metrics数据 时间向量 Sample Metric 构造Metrics 数据抓取 Job Target 采集方式 ...","link":"","photos":[],"count_time":{"symbolsCount":"44k","symbolsTime":"40 mins."},"categories":[{"name":"Monitor","slug":"Monitor","count":1,"path":"api/categories/Monitor.json"}],"tags":[{"name":"Monitor","slug":"Monitor","count":1,"path":"api/tags/Monitor.json"},{"name":"Prometheus","slug":"Prometheus","count":1,"path":"api/tags/Prometheus.json"},{"name":"Metrics","slug":"Metrics","count":1,"path":"api/tags/Metrics.json"}],"author":{"name":"Asura","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Keep runnig!","socials":{"github":"https://github.com/G-Asura","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}
{"title":"容器技术实现原理","uid":"96badec9d2a8ff4ed297d972e3ac1aab","slug":"容器技术实现原理","date":"2022-04-05T14:56:56.000Z","updated":"2022-04-12T04:20:47.325Z","comments":true,"path":"api/articles/容器技术实现原理.json","keywords":null,"cover":[],"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>开始之前为了方便的理解容器，先举个简单的例子：假如把一套房子比作操作系统，这套房子的中控就是内核，每间卧室可以理解为是虚拟化出来的虚拟机，他们可以拥有各自独立的中控，假设这套房子中控控制着台冰箱，冰箱里有多个隔层，那么每个隔层就是一个个独立运行的容器。</p></blockquote>\n<div class=\"toc\">\n\n<!-- toc -->\n\n<ul>\n<li><a href=\"#linux-rong-qi\">Linux容器</a><ul>\n<li><a href=\"#jin-cheng\">进程</a></li>\n<li><a href=\"#namespace\">Namespace</a></li>\n<li><a href=\"#cgroup\">Cgroup</a></li>\n<li><a href=\"#wang-luo\">网络</a></li>\n<li><a href=\"#wen-jian-xi-tong\">文件系统</a></li>\n</ul>\n</li>\n<li><a href=\"#jing-xiang\">镜像</a></li>\n<li><a href=\"#zong-jie\">总结</a></li>\n</ul>\n<!-- tocstop -->\n\n</div>\n\n<h2><span id=\"linux-rong-qi\">Linux容器</span><a href=\"#linux-rong-qi\" class=\"header-anchor\">#</a></h2><h3><span id=\"jin-cheng\">进程</span><a href=\"#jin-cheng\" class=\"header-anchor\">#</a></h3><p>在了解容器之前，我们有必要对Linux进程有一定的了解，因为容器本质上就是一个特殊的进程。<br>关于Linux进程我们先看看下面这张图<br><img src=\"../images/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B.jpg\" alt=\"进程\"></p>\n<ol>\n<li>Linux操作系统启动后切进用户态随之开启进程调度，首先会往GDT（全局描述符表）里写入两个结构TSS（任务状态段）和LDT（局部描述符表）。  </li>\n</ol>\n<ul>\n<li>TSS用来保存和恢复进程的上下文，即各个寄存器的信息；</li>\n<li>LDT与GDT相对应，内核态的代码用GDT里的数据段和代码段，而用户态的进程代码用每个用户自己的LDT里的数据段和代码段。</li>\n</ul>\n<ol start=\"2\">\n<li>接下来会初始化一个长度为64的task_struct的数组来存放所有进程信息，并附上初始值init_task.init，即0号进程的信息。</li>\n<li>最后设置了时钟中断0x20和系统调用0x80，一个作为进程调度的起点，一个作为用户程序调用操作系统功能的桥梁。</li>\n</ol>\n<details class=\"custom-details\">\n<summary>task_struct</summary>\n<p>struct task_struct {<br>/* these are hardcoded - don’t touch <em>/<br>    long state; /</em> -1 unrunnable, 0 runnable, &gt;0 stopped <em>/<br>    long counter;<br>    long priority;<br>    long signal;<br>    struct sigaction sigaction[32];<br>    long blocked; /</em> bitmap of masked signals <em>/<br>  /</em> various fields <em>/<br>    int exit_code;<br>    unsigned long start_code,end_code,end_data,brk,start_stack;<br>    long pid,father,pgrp,session,leader;<br>    unsigned short uid,euid,suid;<br>    unsigned short gid,egid,sgid;<br>    long alarm;<br>    long utime,stime,cutime,cstime,start_time;<br>    unsigned short used_math;<br>  /</em> file system info <em>/<br>    int tty;  /</em> -1 if no tty, so it must be signed <em>/<br>    unsigned short umask;<br>    struct m_inode * pwd;<br>    struct m_inode * root;<br>    struct m_inode * executable;<br>    unsigned long close_on_exec;<br>    struct file * filp[NR_OPEN];<br>  /</em> ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss <em>/<br>    struct desc_struct ldt[3];<br>  /</em> tss for this task */<br>    struct tss_struct tss;<br>};</p>\n</details>\n<p>关于Linux进程，我们还有必要了解一下0号进程和1号进程，尤其是1号进程和容器关系密切。  </p>\n<ul>\n<li>0号进程：0号进程是系统初始化时创建的，即所有进程的父进程，其数据大部分是由预先定义好的INIT_TASK，INIT_MM等宏初始化；  </li>\n<li>1号进程：0号进程通过调用kernel_thread创建一个内核线程去执行init函数，init函数在完成内核初始化后调用execve系统调用，以装入用户空间的可执行程序/sbin/init，这就诞生了真正意义上的init进程，即1号进程。1号进程主要负责执行内核初始化工作及系统配置，并创建若干用于高速缓存和虚拟主存管理的内核线程。  </li>\n</ul>\n<p>1号进程创建后就可以调用execve（）运行init程序，演变成用户态1号进程，根据/etc/initab的配置，接着创建编号1号，2号。。。注册进程getty，从而形成Linux的树形结构进程列表。  </p>\n<p>至此，我们了解了Linux进程的创建过程。那么容器和进程又有什么关系呢？<br>前面我们已经说过了，容器本质上是一个特殊的进程，他的特殊之处又在哪呢？<br>容器进程的特殊性表现在容器进程永远认为自己是1号进程，然而它在系统中的进程号可能是99号，而让容器产生这种特性的技术是Linux的PID Namespace机制。  </p>\n<h3><span id=\"namespace\">Namespace</span><a href=\"#namespace\" class=\"header-anchor\">#</a></h3><p>在我们开始了解Linux Namespace机制之前，我们先来看看上面说的容器进程伪装隔离的实现原理：<br>Linux在创建用户态进程是会调用clone()方法并返回一个int类型的PID<br><code>int pid = clone(main_function, stack_size, SIGCHLD, NULL);</code><br>如果我们传入一个可选参数CLONE_NEWPID，那么新创建的进程将会是一个全新的进程空间，在这个进程空间里，它的进程号就是1，这就是一个容器。<br><code>int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);</code><br>上面就是PID Namespace的实现。  </p>\n<p>Linux Namespace简单来说就是一种资源隔离的机制，主要是三个系统调用clone()，unshare()，setns()。上面提到的进程隔离PID namespace只是众多Namespace中的一种。<br>Linux中还提供了如Mount、Network、User、UTS、IPC等多种资源隔离机制：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Namespace</th>\n<th align=\"center\">用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">PID Namespace</td>\n<td align=\"center\">隔离进程的ID</td>\n</tr>\n<tr>\n<td align=\"center\">Mount Namespace</td>\n<td align=\"center\">隔离文件系统挂载点</td>\n</tr>\n<tr>\n<td align=\"center\">Network Namespace</td>\n<td align=\"center\">隔离网络资源</td>\n</tr>\n<tr>\n<td align=\"center\">User Namespace</td>\n<td align=\"center\">隔离用户和用户组ID</td>\n</tr>\n<tr>\n<td align=\"center\">UTS Namespace</td>\n<td align=\"center\">隔离主机名和域名信息</td>\n</tr>\n<tr>\n<td align=\"center\">IPC Namespace</td>\n<td align=\"center\">隔离进程间通信</td>\n</tr>\n</tbody></table>\n<p>可以在/proc/$pid/ns目录查看Namespace文件信息。<br><img src=\"../images/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/namespace.png\" alt=\"进程\"><br>Namespace机制虽然能帮助我们隔离了资源互不干扰，但是其本质还是在同一个内核进程上创建出来的，共享着宿主机内核，这就限制了不能在不同架构下运行相同的镜像，比如，arm架构的服务器不能运行x86架构下制作的镜像。<br>由于容器进程是共享着宿主机资源，如果只是通过Namespace对容器进行隔离，并不能有效的限制容器之间的资源争抢，以及资源问题导致的容器间运行互相干扰，这时就需要另一项技术Cgroup，对容器进行资源限制。  </p>\n<h3><span id=\"cgroup\">Cgroup</span><a href=\"#cgroup\" class=\"header-anchor\">#</a></h3><p>Linux Cgroup 即 Linux Control Group。它最主要的作用是限制一个进程组资源，包括CPU，Memory，磁盘，带宽等。<br>通常可以在/sys/fs/cgroup路径下看到相应的文件信息，可以通过下面命令查看：<br><code>mount -t cgroup</code>  </p>\n<p>Cgroup通过下面几个子系统协调完成工作：  </p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">子系统</th>\n<th align=\"center\">用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">devices</td>\n<td align=\"center\">设备权限控制</td>\n</tr>\n<tr>\n<td align=\"center\">cpuset</td>\n<td align=\"center\">分配指定的CPU和内存节点</td>\n</tr>\n<tr>\n<td align=\"center\">CPU</td>\n<td align=\"center\">控制CPU使用率</td>\n</tr>\n<tr>\n<td align=\"center\">cpuacct</td>\n<td align=\"center\">统计CPU使用情况</td>\n</tr>\n<tr>\n<td align=\"center\">memory</td>\n<td align=\"center\">限制内存的使用上限</td>\n</tr>\n<tr>\n<td align=\"center\">freezer</td>\n<td align=\"center\">暂停Cgroup中的进程</td>\n</tr>\n<tr>\n<td align=\"center\">blkio</td>\n<td align=\"center\">限制进程的块设备io</td>\n</tr>\n<tr>\n<td align=\"center\">net_cls</td>\n<td align=\"center\">配合流控限制网络带宽</td>\n</tr>\n<tr>\n<td align=\"center\">net_prio</td>\n<td align=\"center\">设置进程的网络流量优先级</td>\n</tr>\n<tr>\n<td align=\"center\">perf_event</td>\n<td align=\"center\">允许Perf工具基于Cgroup分组做性能检测</td>\n</tr>\n<tr>\n<td align=\"center\">huge_tlb</td>\n<td align=\"center\">限制HugeTLB使用</td>\n</tr>\n<tr>\n<td align=\"center\">ns</td>\n<td align=\"center\">可以使不同cgroups下面的进程使用不同的namespace</td>\n</tr>\n</tbody></table>\n<p>内核使用cgroup结构体来表示一个cgroup对一个或者某几个cgroup子系统的资源限制，cgroup结构体就组成了一个树结构。在这个cgroup树上的节点都有一个控制任务列表，一个cgroup可以控制多个进程，同时一个进程也可以加入到多个cgroup中，进程与cgroup是多对多的关系。<br><img src=\"../images/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/cgroup.png\" alt=\"cgroup\"></p>\n<h3><span id=\"wang-luo\">网络</span><a href=\"#wang-luo\" class=\"header-anchor\">#</a></h3><p>我们已经了解到容器是通过Namespace进行资源隔离和Cgroup进行资源限制创建出来的特殊进程，然而新创建的容器怎么与宿主机网络通信以及宿主机上其他Namespace进行通信？这是就要用到上面提到的Network Namespace。<br>Network Namespace的作用是创建以及管理Namespace的网络。可以通过Network Namespace创建多个隔离的网络空间，每个网络空间都拥有独自的网络栈信息。<br>俩个Namespace之间通信可以通过Linux提供的网卡对veth pair实现，但是多个Namespace之间通信如果还借助veth pair来实现就会十分复杂，这个时候就需要借助虚拟网络来实现，虚拟网络有以下三种模式：  </p>\n<ul>\n<li>桥接模式<br><img src=\"../images/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png\" alt=\"桥接模式\"></li>\n<li>NAT模式<br><img src=\"../images/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/NAT%E6%A8%A1%E5%BC%8F.png\" alt=\"NAT模式\"></li>\n<li>主机模式<br><img src=\"../images/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/Host%E6%A8%A1%E5%BC%8F.png\" alt=\"Host模式\"><h3><span id=\"wen-jian-xi-tong\">文件系统</span><a href=\"#wen-jian-xi-tong\" class=\"header-anchor\">#</a></h3>通过Namespace和Cgroup可以有效的隔离和限制容器的运行环境，但是程序的运行还需要文件系统的支撑，这时就要用到我们上面说的Mount Namespace对容器运行的文件系统进行隔离。<br>如果不修改根目录的挂载点，那么容器启动之后会默认继承宿主机的挂载点，如果修改了根目录的挂载点，那么我们创建容器后会得到一个空的根目录。<br>Linux的文件目录挂载涉及下面几个工具：  </li>\n</ul>\n<ol>\n<li>chroot：全称change root file system，这个命令能帮我们将任意目录转化为指定进程的根目录；</li>\n<li>rootfs：负责把除操作系统内核外的文件、配置和目录挂载到容器进程的根目录；</li>\n<li>UnionFS：不同容器的rootfs大多是重合的，为了有效的利用宿主机存储空间，这是就需要对重复的文件就行合并，也就产生了联合挂载Union File System的挂载方式，将多个不同位置的目录联合挂载到同一个目录下面，这也是Docker采用的技术。</li>\n</ol>\n<h2><span id=\"jing-xiang\">镜像</span><a href=\"#jing-xiang\" class=\"header-anchor\">#</a></h2><p>Docker结合UnionFS技术，使用多个增量的rootfs联合挂载一个完整的rootfs，就此诞生了分层镜像。这样的分层结构极大的利用了宿主机的存储空间，并且还能基础镜像上进行堆叠不同的层，使得使用更加灵活，扩展性更强，同时保证了基础镜像的强一致性。<br>Docker image分层结构：<br><img src=\"../images/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image.jpg\" alt=\"images\"></p>\n<h2><span id=\"zong-jie\">总结</span><a href=\"#zong-jie\" class=\"header-anchor\">#</a></h2><p>通过对进程、Namespace、Cgroup和Rootfs的了解，容器归根结底是一个特殊的进程，它的特殊性可以概括为下面的等式：<br><code>容器 = Namespace + Cgroups + Rootfs + 容器引擎</code></p>\n","text":" 开始之前为了方便的理解容器，先举个简单的例子：假如把一套房子比作操作系统，这套房子的中控就是内核，每间卧室可以理解为是虚拟化出来的虚拟机，他们可以拥有各自独立的中控，假设这套房子中控控制着台冰箱，冰箱里有多个隔层，那么每个隔层就是一个个独立运行的容器。 Linux容器 进程 N...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"Container","slug":"Container","count":1,"path":"api/categories/Container.json"}],"tags":[{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"},{"name":"Container","slug":"Container","count":1,"path":"api/tags/Container.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Linux容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">进程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Namespace</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Cgroup</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">网络</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">文件系统</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">镜像</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"Asura","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Keep runnig!","socials":{"github":"https://github.com/G-Asura","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Prometheus数据流","uid":"78cf92f2c0639bec80519c22649cfa6b","slug":"Prometheus数据流","date":"2022-04-08T08:46:07.000Z","updated":"2022-04-12T04:20:58.958Z","comments":true,"path":"api/articles/Prometheus数据流.json","keywords":null,"cover":[],"text":" Prometheus是一个开源的监控和报警工具。它优秀的设计理念，灵活的扩展，丰富的生态以及活跃的社区使它正在成为众多开发者喜爱的监控工具。 简介 数据拉取 Metrics数据 时间向量 Sample Metric 构造Metrics 数据抓取 Job Target 采集方式 ...","link":"","photos":[],"count_time":{"symbolsCount":"44k","symbolsTime":"40 mins."},"categories":[{"name":"Monitor","slug":"Monitor","count":1,"path":"api/categories/Monitor.json"}],"tags":[{"name":"Monitor","slug":"Monitor","count":1,"path":"api/tags/Monitor.json"},{"name":"Prometheus","slug":"Prometheus","count":1,"path":"api/tags/Prometheus.json"},{"name":"Metrics","slug":"Metrics","count":1,"path":"api/tags/Metrics.json"}],"author":{"name":"Asura","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Keep runnig!","socials":{"github":"https://github.com/G-Asura","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{}}
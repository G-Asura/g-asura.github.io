<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="容器技术实现原理"><meta name="keywords" content="Container"><meta name="author" content="Asura,undefined"><meta name="copyright" content="Asura"><title>容器技术实现原理【Asura】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Asura" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Linux容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.</span> <span class="toc-text">Namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.</span> <span class="toc-text">Cgroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.</span> <span class="toc-text">网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.</span> <span class="toc-text">文件系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">Asura</div><div class="author-info-description">Keep runnig!</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/DevilAndAngel" target="_blank">GitHub<i class="icon-dot bg-color2"></i></a><a class="links-button button-hover" href="mailto:1780896043@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="tencent://message/?uin=1780896043&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color4"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">2</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">2</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Asura</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">容器技术实现原理</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2022-04-05 | 更新于 2022-04-07</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Linux/">Linux</a><i class="fa fa-angle-right" style="margin: 0 8px;"></i><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Linux/Container/">Container</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Container/">Container</a></div></div></div><div class="main-content"><blockquote>
<p>开始之前为了方便的理解容器，先举个简单的例子：假如把一套房子比作操作系统，这套房子的中控就是内核，每间卧室可以理解为是虚拟化出来的虚拟机，他们可以拥有各自独立的中控，假设这套房子中控控制着台冰箱，冰箱里有多个隔层，那么每个隔层就是一个个独立运行的容器。</p>
</blockquote>
<h2><span id="linux容器">Linux容器</span></h2><h3><span id="进程">进程</span></h3><p>在了解容器之前，我们有必要对Linux进程有一定的了解，因为容器本质上就是一个特殊的进程。<br>关于Linux进程我们先看看下面这张图<br><img src="../images/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B.jpg" alt="进程"></p>
<ol>
<li>Linux操作系统启动后切进用户态随之开启进程调度，首先会往GDT（全局描述符表）里写入两个结构TSS（任务状态段）和LDT（局部描述符表）。  </li>
</ol>
<ul>
<li>TSS用来保存和恢复进程的上下文，即各个寄存器的信息；</li>
<li>LDT与GDT相对应，内核态的代码用GDT里的数据段和代码段，而用户态的进程代码用每个用户自己的LDT里的数据段和代码段。</li>
</ul>
<ol start="2">
<li>接下来会初始化一个长度为64的task_struct的数组来存放所有进程信息，并附上初始值init_task.init，即0号进程的信息。</li>
<li>最后设置了时钟中断0x20和系统调用0x80，一个作为进程调度的起点，一个作为用户程序调用操作系统功能的桥梁。</li>
</ol>
<blockquote>
<p> struct task_struct {<br>/* these are hardcoded - don’t touch <em>/<br>    long state; /</em> -1 unrunnable, 0 runnable, &gt;0 stopped <em>/<br>    long counter;<br>    long priority;<br>    long signal;<br>    struct sigaction sigaction[32];<br>    long blocked; /</em> bitmap of masked signals <em>/<br>  /</em> various fields <em>/<br>    int exit_code;<br>    unsigned long start_code,end_code,end_data,brk,start_stack;<br>    long pid,father,pgrp,session,leader;<br>    unsigned short uid,euid,suid;<br>    unsigned short gid,egid,sgid;<br>    long alarm;<br>    long utime,stime,cutime,cstime,start_time;<br>    unsigned short used_math;<br>  /</em> file system info <em>/<br>    int tty;  /</em> -1 if no tty, so it must be signed <em>/<br>    unsigned short umask;<br>    struct m_inode * pwd;<br>    struct m_inode * root;<br>    struct m_inode * executable;<br>    unsigned long close_on_exec;<br>    struct file * filp[NR_OPEN];<br>  /</em> ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss <em>/<br>    struct desc_struct ldt[3];<br>  /</em> tss for this task */<br>    struct tss_struct tss;<br>};  </p>
</blockquote>
<p>关于Linux进程，我们还有必要了解一下0号进程和1号进程，尤其是1号进程和容器关系密切。  </p>
<ul>
<li>0号进程：0号进程是系统初始化时创建的，即所有进程的父进程，其数据大部分是由预先定义好的INIT_TASK，INIT_MM等宏初始化；  </li>
<li>1号进程：0号进程通过调用kernel_thread创建一个内核线程去执行init函数，init函数在完成内核初始化后调用execve系统调用，以装入用户空间的可执行程序/sbin/init，这就诞生了真正意义上的init进程，即1号进程。1号进程主要负责执行内核初始化工作及系统配置，并创建若干用于高速缓存和虚拟主存管理的内核线程。  </li>
</ul>
<p>1号进程创建后就可以调用execve（）运行init程序，演变成用户态1号进程，根据/etc/initab的配置，接着创建编号1号，2号。。。注册进程getty，从而形成Linux的树形结构进程列表。  </p>
<p>至此，我们了解了Linux进程的创建过程。那么容器和进程又有什么关系呢？<br>前面我们已经说过了，容器本质上是一个特殊的进程，他的特殊之处又在哪呢？<br>容器进程的特殊性表现在容器进程永远认为自己是1号进程，然而它在系统中的进程号可能是99号，而让容器产生这种特性的技术是Linux的PID Namespace机制。  </p>
<h3><span id="namespace">Namespace</span></h3><p>在我们开始了解Linux Namespace机制之前，我们先来看看上面说的容器进程伪装隔离的实现原理：<br>Linux在创建用户态进程是会调用clone()方法并返回一个int类型的PID<br><code>int pid = clone(main_function, stack_size, SIGCHLD, NULL);</code><br>如果我们传入一个可选参数CLONE_NEWPID，那么新创建的进程将会是一个全新的进程空间，在这个进程空间里，它的进程号就是1，这就是一个容器。<br><code>int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);</code><br>上面就是PID Namespace的实现。  </p>
<p>Linux Namespace简单来说就是一种资源隔离的机制，主要是三个系统调用clone()，unshare()，setns()。上面提到的进程隔离PID namespace只是众多Namespace中的一种。<br>Linux中还提供了如Mount、Network、User、UTS、IPC等多种资源隔离机制：</p>
<table>
<thead>
<tr>
<th align="center">Namespace</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PID Namespace</td>
<td align="center">隔离进程的ID</td>
</tr>
<tr>
<td align="center">Mount Namespace</td>
<td align="center">隔离文件系统挂载点</td>
</tr>
<tr>
<td align="center">Network Namespace</td>
<td align="center">隔离网络资源</td>
</tr>
<tr>
<td align="center">User Namespace</td>
<td align="center">隔离用户和用户组ID</td>
</tr>
<tr>
<td align="center">UTS Namespace</td>
<td align="center">隔离主机名和域名信息</td>
</tr>
<tr>
<td align="center">IPC Namespace</td>
<td align="center">隔离进程间通信</td>
</tr>
</tbody></table>
<p>可以在/proc/$pid/ns目录查看Namespace文件信息。<br><img src="../images/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/namespace.png" alt="进程"><br>Namespace机制虽然能帮助我们隔离了资源互不干扰，但是其本质还是在同一个内核进程上创建出来的，共享着宿主机内核，这就限制了不能在不同架构下运行相同的镜像，比如，arm架构的服务器不能运行x86架构下制作的镜像。<br>由于容器进程是共享着宿主机资源，如果只是通过Namespace对容器进行隔离，并不能有效的限制容器之间的资源争抢，以及资源问题导致的容器间运行互相干扰，这时就需要另一项技术Cgroup，对容器进行资源限制。  </p>
<h3><span id="cgroup">Cgroup</span></h3><p>Linux Cgroup 即 Linux Control Group。它最主要的作用是限制一个进程组资源，包括CPU，Memory，磁盘，带宽等。<br>通常可以在/sys/fs/cgroup路径下看到相应的文件信息，可以通过下面命令查看：<br><code>mount -t cgroup</code>  </p>
<p>Cgroup通过下面几个子系统协调完成工作：  </p>
<table>
<thead>
<tr>
<th align="center">子系统</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">devices</td>
<td align="center">设备权限控制</td>
</tr>
<tr>
<td align="center">cpuset</td>
<td align="center">分配指定的CPU和内存节点</td>
</tr>
<tr>
<td align="center">CPU</td>
<td align="center">控制CPU使用率</td>
</tr>
<tr>
<td align="center">cpuacct</td>
<td align="center">统计CPU使用情况</td>
</tr>
<tr>
<td align="center">memory</td>
<td align="center">限制内存的使用上限</td>
</tr>
<tr>
<td align="center">freezer</td>
<td align="center">暂停Cgroup中的进程</td>
</tr>
<tr>
<td align="center">blkio</td>
<td align="center">限制进程的块设备io</td>
</tr>
<tr>
<td align="center">net_cls</td>
<td align="center">配合流控限制网络带宽</td>
</tr>
<tr>
<td align="center">net_prio</td>
<td align="center">设置进程的网络流量优先级</td>
</tr>
<tr>
<td align="center">perf_event</td>
<td align="center">允许Perf工具基于Cgroup分组做性能检测</td>
</tr>
<tr>
<td align="center">huge_tlb</td>
<td align="center">限制HugeTLB使用</td>
</tr>
<tr>
<td align="center">ns</td>
<td align="center">可以使不同cgroups下面的进程使用不同的namespace</td>
</tr>
</tbody></table>
<p>内核使用cgroup结构体来表示一个cgroup对一个或者某几个cgroup子系统的资源限制，cgroup结构体就组成了一个树结构。在这个cgroup树上的节点都有一个控制任务列表，一个cgroup可以控制多个进程，同时一个进程也可以加入到多个cgroup中，进程与cgroup是多对多的关系。<br><img src="../images/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/cgroup.png" alt="cgroup"></p>
<h3><span id="网络">网络</span></h3><p>我们已经了解到容器是通过Namespace进行资源隔离和Cgroup进行资源限制创建出来的特殊进程，然而新创建的容器怎么与宿主机网络通信以及宿主机上其他Namespace进行通信？这是就要用到上面提到的Network Namespace。<br>Network Namespace的作用是创建以及管理Namespace的网络。可以通过Network Namespace创建多个隔离的网络空间，每个网络空间都拥有独自的网络栈信息。<br>俩个Namespace之间通信可以通过Linux提供的网卡对veth pair实现，但是多个Namespace之间通信如果还借助veth pair来实现就会十分复杂，这个时候就需要借助虚拟网络来实现，虚拟网络有以下三种模式：  </p>
<ul>
<li>桥接模式<br><img src="../images/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png" alt="桥接模式"></li>
<li>NAT模式<br><img src="../images/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/NAT%E6%A8%A1%E5%BC%8F.png" alt="NAT模式"></li>
<li>主机模式<br><img src="../images/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/Host%E6%A8%A1%E5%BC%8F.png" alt="Host模式"><h3><span id="文件系统">文件系统</span></h3>通过Namespace和Cgroup可以有效的隔离和限制容器的运行环境，但是程序的运行还需要文件系统的支撑，这时就要用到我们上面说的Mount Namespace对容器运行的文件系统进行隔离。<br>如果不修改根目录的挂载点，那么容器启动之后会默认继承宿主机的挂载点，如果修改了根目录的挂载点，那么我们创建容器后会得到一个空的根目录。<br>Linux的文件目录挂载涉及下面几个工具：  </li>
</ul>
<ol>
<li>chroot：全称change root file system，这个命令能帮我们将任意目录转化为指定进程的根目录；</li>
<li>rootfs：负责把除操作系统内核外的文件、配置和目录挂载到容器进程的根目录；</li>
<li>UnionFS：不同容器的rootfs大多是重合的，为了有效的利用宿主机存储空间，这是就需要对重复的文件就行合并，也就产生了联合挂载Union File System的挂载方式，将多个不同位置的目录联合挂载到同一个目录下面，这也是Docker采用的技术。</li>
</ol>
<h2><span id="镜像">镜像</span></h2><p>Docker结合UnionFS技术，使用多个增量的rootfs联合挂载一个完整的rootfs，就此诞生了分层镜像。这样的分层结构极大的利用了宿主机的存储空间，并且还能基础镜像上进行堆叠不同的层，使得使用更加灵活，扩展性更强，同时保证了基础镜像的强一致性。<br>Docker image分层结构：<br><img src="../images/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image.jpg" alt="images"></p>
<h2><span id="总结">总结</span></h2><p>通过对进程、Namespace、Cgroup和Rootfs的了解，容器归根结底是一个特殊的进程，它的特殊性可以概括为下面的等式：<br><code>容器 = Namespace + Cgroups + Rootfs + 容器引擎</code></p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Asura</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="http://gasura.cn/2022/04/05/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">http://gasura.cn/2022/04/05/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://gasura.cn">Asura</a>！</span></div></div></article><div id="pagination"><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2022/04/05/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E5%AF%B9%E6%AF%94/"><span>开源协议对比</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2020 ～ 2022 By Asura</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>